## Unity Shader入门学习##
### 渲染流水线 ###
渲染流水线从概念部分分为三个部分：  

- **应用阶段**  
应用阶段为开发者完全控制部分，主要提供渲染所需要的渲染数据，输出为渲染图元，该阶段可以细分为： 
- 加载渲染数据（HDD-->RAM-->VRAM）    
- 设置渲染状态（决定场景中的网格（图元）以怎样的方式渲染，使用什么着色器，光照，材质）  
- 调用DrawCall命令（指定需要渲染的图元列表，发起方为CPU，接收方为GPU）   

- **几何阶段**  
几何阶段的部分过程可以由开发者控制和配置，几何阶段主要将接收到的图元信息进行逐顶点，逐多边形操作，将顶点坐标变换到屏幕空间，同时记录顶点的光照，深度，着色信息。该阶段可以细分为：   
- 顶点着色器（该阶段可编程阶段，将顶点坐标从模型空间转换到齐次裁剪空间，顶点着色，纹理坐标输出也在该过程完成）  
- 曲面细分着色器（可选着色器，细分图元）  
- 几何着色器（可选着色器，进行逐图元操作，或者被用于产生更多图元）  
- 裁剪（将不在摄像机视野中的顶点裁剪掉） 
- 屏幕映射（将图元的顶点转换到屏幕空间坐标系，该过程不可编程或配置）

- **光栅化阶段**  
该阶段接收上一阶段的顶点信息，并对顶点所围成的网格覆盖的像素进行逐像素的处理，输出最终的渲染图像，该过程可以细分为：
- 三角形设置（该阶段将得到的顶点进行计算，得到顶点围成的三角网格的边上的像素坐标）
- 三角形遍历（根据上一步的计算结果，判断哪些像素点在网格内，并对覆盖的像素点进行插值，这里由于每个像素点上除了颜色信息，还包括光照，深度，纹理坐标等信息，将带有信息的像素点成为片元，这一过程的输出为片元序列）
- 片元着色器（该阶段为可编程着色阶段，输入为上一阶段的顶点信息的插值结果，许多较为重要的渲染技术在该阶段完成，如纹理采样，该阶段若要进行纹理采样，那么在顶点着色器阶段输出每个顶点对应的纹理坐标）  
- 逐片元操作（该过程为渲染流水线的最后阶段，也被称作合并输出阶段，主要是对每个片元进行模板，深度测试，混合操作等，通过测试的可以选择是否与颜色缓冲区的颜色进行混合，从而决定片元的可见度以及最终的颜色）

**shader**是渲染流水线中的一部分可高度编程的阶段，**Unity**中的**Shader**主要对  几何阶段的**顶点着色器**和光栅化阶段的**片元着色器**进行编程操作。 

### Shader Lab ###
在Unity中，所有的Unity Shader都是使用ShaderLab来编写的。Shader Lab是Unity提供编写Unity Shader的一种说明性语言，使用嵌套在花括号内部的语义来描述Unity Shader文件的结构。   
一个Unity Shader的基础结构：
		
		Shader "ShaderName"{
			properties{
				//属性
			}
			SubShader{
				//显卡A使用的子着色器
			}
			SubShader{
				//显卡B使用的子着色器
			}
			FallBack "VertexLit"
		}  
Unity Shader和通用的Shader不太一样，Unity在背后根据使用的平台将这些结构编译成正真意义上的Shader代码和文件，Unity开发者不必太关心底层的渲染，只用使用Unity Shader Lab即可。   

### Unity Shader结构及语义 ###
**Properties**  
*Properties*语义块中包括一系列的属性（Property）, **这些属性会出现在材质面板中**，*Properties*语义块定义：

		Properties{
			_name("display name",PropertyType)=DefaultValue
			_name("display name",PropertyType)=DefaultValue
			//更多属性
		}

属性的声明可以使我们很方便的在材质面板中看到这些属性，并对这些属性进行调节，**display name**是该属性在材质面板中的显示的名字，若要在后续的CG代码中使用这些属性，则是通过**_name**进行访问，每种属性在声明时，需要指定属性的类型，并给附上默认值。完整的属性及类型和默认值赋值方式为：

		Sahder "ShaderLabProperties"{
			Properties{
		_Int("Int",Int)=2
		_Float("Float",Float)=1.5
		_Range("Range",Range(0.0,5.0))=3.0
		//
		_Color("Color",Color)=(1,1,1,1)
		_Vector("Vector",Vector)=(2,3,6,1)
		//
		_2D("2D",2D)=""{}
		_Cube("Cube",Cube)="white"{}
		_3D("3D",3D)="black"{}
		}
	}
**值得注意的是**，在Shader Lab的语义块中，每行语句结尾是没有；的，对于2D，3D，Cube这3种纹理类型，默认值的定义通过一个字符串后跟一对{}来完成，其中，字符串要么为空，要么为内置纹理名称，如"gray","red","bump"等。Properties语义块的作用只是将定义的属性显示到材质面板中， **后续的Shader代码中若要访问这些属性，需要在CG代码片段中定义和这些属性相匹配的变量。**

**SubShader**  
每一个Unity Shader文件可以包含1个或多个*SubShader* 语义块，这是由于不同的显卡具有不同的渲染能力，多个 *SubShader* 对应着多个显卡，这样在不同能力的显卡上进行不同复杂度的渲染计算。     
*SubShader*语义块通常结构如下：    
			
		SubShader{
		//可选  
		[Tags]

		//可选
		[RenderSetup] 

		Pass{
		}
		//Other Pass
	}
需要注意的地方：   

- SubShader包括一系列Pass,可选的Tags,可选的RenderSetup，每一个Pass为一次完整的渲染流程
- Tags为可选的，可以在SubShader和Pass内声明，SubShader内声明的Tags是特定的
- RenderSetup为可选的，可以在SubShader和Pass内声明，非特定的，即在SubShader和Pass内可通用
- Tags和RenderSetup若在SubShader中进行了设置，会应用到所有的Pass中去    

*Tags*是一个键值对，其结构为：
	
	Tags{"TagsName1"="Value1" "TagsName2"="Value2"}

**Pass语义块**  
Pass语义块为*SubShader*的一部分，语义结构如下：

		Pass{
		[Name]
		[Tags]
		[RenderSetup]
		//Other Code
		}  
在Pass语义块中，可以定义该段Pass的名字，如：

		[FirstPass]    
定义了Pass的名字后，可以通过  

		UsePass "FirstShader/FIRSTPASS"  
来使用其他Unity Shader的Pass，提高复用性。由于Unity Shader的内部会将所有的Pass的名称转换成大写形式，因此在使用UsePass时，使用大写的Pass名称。   
Pass语义块中，可以设置Tags，与SubShader中的不同，Pass中可用的Tags有LightMode,RequireOptions   
Pass语义块中，可以设置RenderSetup,与SubShader中的设置通用，应用于当前的Pass  
Unity Shader支持一些特殊的Pass，以实现代码复用和更为复杂的功能，如：  

- **UsePass:**使用该命令复用其他Unity Shader的Pass
- **GrabPass:**该Pass负责抓取屏幕将结果存储在一张纹理当中，用于后续Pass的处理

**Fallback**  
在最后一个SubShader的语义块后面，有一个Fallback指令，如果所有的SubShader都不能被当前显卡运行，那就使用Fallback指定的Shader，如：  

		Fallback "VertexLit"   

在Unity Shader中，真正意义上的Shader代码都会写在SubShader语义块中：    

		Shader "FirstShader"{
		Properties{
		//所需各种属性
		}
		SubShader{
		//真正意义上的Shader代码会写在这部分中
		//表面着色器(Surface Shader)或者
		//顶点/片元着色器（Vertex/Fragment Shader）或者
		//固定函数着色器(Fixed Function Shader)
		}
		SubShader{
		}
		}  

### 相关数学内容 ###
**变换**  
变换指将一些数据，例如，点，方向矢量甚至颜色，通过某种方式进行转换的过程。   
线性变换是非常常见的一种变化类型，满足矢量加和标量乘的变换即为线性变换，即：

**f(x)+f(y)=f(x+y)**     
k**f(x)**=**f(**k**x)**    

**缩放**和**旋转**是一种线性变换，**错切**，**镜像**，**正交投影**也是线性变化。  

**平移**不属于线性变化，比如**f**(x)=x+(1,2,3)，因为不满足矢量加和标量乘的运算。 

线性变换使用3X3的矩阵即可表示，但由于**平移**变换不属于线性变换，因此无法使用3X3的矩阵来表示平移，需要将矢量扩展到四维空间下，即**齐次坐标空间**  

三维坐标-->齐次坐标空间（*w*分量设为1）   
方向矢量-->齐次坐标空间 (*w*分量设为0)  
当使用4X4矩阵对一个点进行变换时，平移、旋转和缩放会施加于该点，而对于一个方向矢量，平移的效果则会被忽略。  

**基础变换矩阵**   
用于表示**纯平移**、**纯旋转**和**纯缩放**的的变换矩阵为**基础变换矩阵**。基础变换矩阵的分解：   
**M（3x3）**        **T(3x1)**     
**0 (1x3)**         **1**   
其中，**M（3x3）**用于表示旋转和缩放部分，**T（3x1）**用于表示平移部分  

**复合变换**   
平移、缩放和旋转可以组合起来，形成复杂的变化过程。由于矩阵的乘法不满足交换律，因此不同的变换顺序得到的结果是不一样的。绝大多数情况下约定变换顺序为：缩放，旋转，再平移即(Unity中矢量一般化为列矩阵，放在变换右侧运算)：  

**P（new）=M(translation) M(rotation) M(scale) P(old)**  

这样的运算顺序符合预期，例如位于原点的坐标，先向z平移5个单位,即(0,0,5)，再扩大两倍，得到（0,0,10），这样实际上位置已经不符合预期。因此先进行缩放，再旋转，最后平移。 

复合旋转同样需要注意旋转的顺序，当给定（θx,θy,θz）的旋转角度，得到的组合变换旋转矩阵为： 

**Mθz Mθx Mθy**  

**坐标空间的变换**  
定义一个坐标空间需要其原点位置和3个坐标轴的方向的表示。原点位置和坐标轴的表示实际上是相对于另一个坐标系而言。对坐标空间的变换实际上就是在父空间和子空间之间对点和矢量进行变换。即： 

**A**p=**Mc-p** **A**c (将子空间的坐标或矢量变换到父空间)  
**B**c=**Mp-c** **B**p (将父空间的坐标或矢量变化到子空间) 

**Mc-p**表示从子坐标空间变换到父坐标空间的变换矩阵，**Mp-c**是其逆矩阵。   

若已知子坐标空间**C**中的3个坐标轴在父坐标空间**P**下的表示 **Xc** **Yc** **Zc** 以及其原点位置 **Oc** ，给定一个子坐标空间中的一点Ac=(a,b,c)

坐标的变化过程：    
Ap=**Oc** +a **Xc** +b **Yc** +c **Zc**    
  =(Xoc,Yoc,Zoc)+a(Xxc,Yxc,Zxc)+b(Xyc,Yyc,Zyc)+c(Xzc,Yzc,Zzc)   
  =((Xoc,Yoc,Zoc)+  
  |Xxc Xyc Xzc| a  
  |Yxc Yyc Yzc| b   
  |Zxc Zyc Zzc| c   
原点的加法部分属于平移变换，因此转换到齐次坐标空间下：   
  |1 0 0 Xoc||Xxc Xyc Xzc 0| a  
  |0 1 0 Yoc||Yxc Yyc Yzc 0| b  
  |0 0 1 Zoc||Zxc Zyc Zzc 0| c  
  |0 0 0 __1|| _0  _0 _0 _1| 1  
左侧两个矩阵进一步合并：  
  |Xxc Xyc Xzc Xoc| a  
  |Yxc Yyc Yzc Yoc| b  
  |Zxc Zyc Zzc Zoc| c  
  | _0  _0 _0  ___1| 1  
由此，**Mc-p**即为：  
  |Xxc Xyc Xzc Xoc|   
  |Yxc Yyc Yzc Yoc|   
  |Zxc Zyc Zzc Zoc|   
  | _0  _0 _0  ___1|   

若是对**矢量**进行变换的话，平移的过程是不需要的，因为一个矢量平移没有意义，所以矢量的变换矩阵为前3X3：  
  |Xxc Xyc Xzc|   
  |Yxc Yyc Yzc|   
  |Zxc Zyc Zzc|   
因此在Shader中，经常会有截取变换矩阵的前3X3对法线方向、光照方向进行空间变换。  

这里值得注意的地方，假如**Mc-p**是一个正交矩阵，那么**Mp-c**即为**Mc-p**T （**Mc-p**-1 = **Mc-p**T）  
这里变换矩阵的 **Mc-p** 前3X3就是 **Xc** **Yc** **Zc** 分别以**列的形式** 填充得到的矩阵，若是正交矩阵， 以**行的形式** 填充矩阵即可得到 **Mp-c**  

**顶点的坐标空间变换过程**  


- **模型空间**    
每个模型都有自己独立的坐标空间，当模型移动或旋转的时候，模型空间也会跟着移动或旋转。    


- **世界空间**  
世界空间是关心的最外层的坐标空间，在Unity中，即为场景空间空间。这里有一点注意的是，在Unity中，游戏对象的Transform组件中显示的坐标信息是相对于其父对象的坐标空间的，如果该游戏对象没有父对象，则坐标信息为世界空间的坐标信息。  

- **观察空间**   
观察空间可以看做模型空间的一个特列，即摄像机，也可以被称为摄像机空间。Unity中，观察空间的坐标轴的方向为：+x轴指向右方，+y轴指向上方，+z轴指向摄像机的后方，注意**观察空间使用的是右手坐标系**，摄像机的正前方指向-z轴方向。   

- **裁剪空间**   
裁剪空间的目的是能够方便地对渲染图元进行裁剪。处于这个空间内的图元会被保留，位于这个空间外的就会被剔除，与这块相交的图元会被裁剪。裁剪空间由视锥体决定。 

- **屏幕空间**
经过投影矩阵的变换后，可以进行裁剪操作。当裁剪完成后，进行真正的投影，将视锥体投影到屏幕空间，生成对应的2D坐标，得到真正的像素位置。

**顶点变换第一步：模型空间-->世界空间**   
根据游戏对象的Transform信息，得到游戏对象在世界空间中进行的缩放，旋转，平移信息，构建变换矩阵，从右往左，依次是缩放，旋转，平移，得到变换矩阵，顶点坐标根据该变换矩阵运算得到在世界空间下的表示。  


**顶点变换第二步：世界空间-->观察空间**  
取得从世界空间到观察空间的变换矩阵有两种方法。   
第一种是通过摄像机的Transform组件信息，得到从观察空间到模型空间的变换矩阵，再通过这个变换矩阵求出逆矩阵，即为世界空间到观察空间的变换矩阵。    
第二种是通过将摄像机回到世界空间的原点，坐标轴与世界空间坐标轴重合，得到一个变换矩阵，顶点通过与这个矩阵运算得到新的坐标位置，这个坐标的值即为在观察空间下的坐标值，**这里有一点需要注意**，由于观察空间是右手坐标系，因此得到的变换矩阵还是相当于左手坐标系下，因此还需要做一个变化，使Z轴反向。在该矩阵的基础上乘上：  
|1 0 0 0|  
|0 1 0 0|  
|0 0 -1 0|  
|0 0 0 1|  

**顶点变换的第三步：观察空间-->裁剪空间**   
观察空间到裁剪空间的转换过程中，不管是透视投影的是视锥体还是正交投影的视锥体，都有对应的透视矩阵进行运算。视锥体是摄像机能够看到的空间。分为两种类型，对应两种投影，分别是**透视投影** 和 **正交投影**。如果直接使用视锥体围成的空间对图元进行裁剪，不同的视锥体的处理方式就不一样，而且在透视投影的视锥体下判断一个图元是否在视锥体内计算非常麻烦。因此，通过一个投影矩阵将顶点转换到裁剪空间内能得到一个更加通用的处理过程。在经过投影矩阵的转换之后，齐次坐标空间的*w*分量会作为一个范围值，如果x,y,z的值在这个范围内，说明该顶点位于裁剪空间内。 

**顶点变换的第四步：裁剪空间-->屏幕空间**  
把顶点从裁剪空间投影到屏幕空间中，生成对应的2D坐标，有两个步骤。   
**步骤1：齐次除法（透视除法）**  
该过程使用齐次坐标系的*w*分量去除以x,y,z分量。这一步得到的坐标可以称为**归一化设备坐标（NDC）**。经过投影矩阵变换得到的裁剪空间，经过齐次除法后，变化到一个立方体内。  
**步骤2：屏幕映射**  
这时，变化后的坐标均在[-1,1]内，而在Unity中，屏幕空间的左下角坐标为（0,0），右上角坐标为（pixelWidth，pixelHeight）因此将坐标进行一个映射过程,即：   
Pixelx=（1/2 * Xndc+1/2） * pixelWidth    
Pixely=（1/2 * Yndc+1/2） * pixelHeight   

**顶点着色器** 的最基本任务是将顶点坐标从**模型空间** 变换到 **裁剪空间**，对应着3个变换矩阵，即**模型变换** ，**观察变换**，**投影变换**，在顶点着色器中通常将这三个矩阵串联成一个矩阵，即**MVP**，用于将顶点坐标从**模型空间** 变换到 **裁剪空间**。   

而从**裁剪空间** 到 **屏幕空间** 的转换过程是由Unity完成的，所以顶点着色器只完成顶点从模型空间到裁剪空间即可。