## 数据结构学习笔记 ##

### 数据结构相关概念 ###
数据结构的相关概念：         
![](https://i.imgur.com/OSvaWbm.png)        
![](https://i.imgur.com/iGXBKz0.png)         

### 初识算法及相关概念 ###

- **算法**      
解决特定问题的求解步骤及描述，在计算机中为指令的有限序列，每条指令表示一个或多个操作。

- **算法特性**     
有穷性、确定性、可行性、输入、输出      

- **算法设计要求**     
正确性、可读性、健壮性、高效率和低存储量需求         

- **算法时间复杂度及大O阶推导**         
大O阶推导：     
1.使用常数1代替运行时间中的所有常数加法     
2.修改后的运行次数函数中，只保留最高阶项         
3.如果最高阶项存在且系数不为1，去除该项的系数        
常见的时间复杂度耗时排列：          
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(!n)<O(n^n)          

一般而言，所指的时间复杂度通常是指最坏情况的耗时时间。      

### 线性表 ###
线性表：零个或多个数据元素的有限序列          
线性表的两种存储结构：**顺序存储&链式存储**         

**单链表结构&顺序存储结构对比**        
![](https://i.imgur.com/IWJzp1A.png)        

- 若线性表需要频繁的读取而插入和删除操作较少时，顺序存储结构更加合适，若有频繁的插入和删除操作，则单链表结构更加合适。
- 当线性表元素变化较大或者不知道有多大时，单链表结构更加合适，不需要考虑内存预先存储空间的大小问题，而如果已知具体长度，则使用顺序存储效率较高       

**静态链表**        
用数组描述的链表叫做静态链表     
静态链表的优缺点：       
![](https://i.imgur.com/Wn4HsVV.png)               
静态链表实际上是给没有指针的高级语言设计的一种实现单链表的方法，尽管存在一定缺陷，其设计思想十分巧妙。     

**栈与队列**     
**栈**是限定仅在表尾进行插入和删除操作的线性表      
**队列**是只允许在一端插入数据在另一端删除数据的线性表  

**顺序栈与链栈对比**           

- 插入删除时间复杂度均为O[1]  
- 对于空间复杂度，顺序栈需要事先确定长度，会存在内存空间浪费问题 ；链栈存取定位方便，但需要指针域增大存储开销。如果栈的长度不确定，使用链栈，反之使用顺序栈比较合适。   

**串**       
串是指零个或多个字符组成的有限序列，又叫字符串。      

串的顺序存储一般使用定长数组进行定义，对于字符串操作存在的溢出问题，串值的存储空间在执行过程中动态分配**堆内存**，由动态分配函数malloc()和free()来管理      

串的链式存储结构除了在串的连接操作会方便一些，总体不如顺序结构灵活，性能也不如顺序存储结构      

### 树 ###
树是n个结点的有限集，当n=0时，为空树。在任意一个非空树中有且仅有一个特定的称为**根**的结点；当n>1时，其余结点可以分为m个互不相交的有限集，每一个集合本身又是一棵树，称为**根的子树**     

数的结点包含一个数据元素&**若干个**指向其子树的分支。结点拥有的子树的数目称为 **结点的度**。度为0的结点称为叶节点或终端结点，度不为0的结点，称为分支结点，分支结点中除了根节点，其他结点也称为内部节点。数的度为树内所有结点的最大值。   

结点的层次从根结点开始定义，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度或高度。    

**线性表与树结构的差异**           
![](https://i.imgur.com/cc8RHTR.png)       

**树的抽象数据类型ADT**     
![](https://i.imgur.com/aZUXbhq.png)      
树的存储结构       
对于树这种存在一对多的情况，单纯使用顺序存储无法满足其逻辑关系。结合顺序存储和链式存储可以实现对树的存储结构的要求。   
常见的三种不同的表示法：双亲表示法、孩子表示法（双亲-孩子结合的表示法）、孩子兄弟表示法。   

![](https://i.imgur.com/kZ3Un8A.png)        
双亲表示法： 
通过一定长度的结点数组存储结点（结点存储结点数据和双亲下标）    
![](https://i.imgur.com/NcKfbG8.png)      
双亲表示法中根据结点的parent可以找到其双亲，但是无法找到结点的子结点，除非是遍历整个树。可以对结点的数据域进行扩展，增加长子索引。可以根据需求继续扩展结点数据域。          
![](https://i.imgur.com/0kcbdwO.png)       

孩子表示法：         
孩子表示法为在结点数组中，每个结点形成一个单链表的结构，链表中的下一个元素为该结点的兄弟。        
![](https://i.imgur.com/0ONs0Bp.png)        

兄弟表示法      
兄弟表示法中，每个结点如果存在长子结点，有且只有一个，而结点紧邻右侧的兄弟若存在，有且只有一个。这样在结点数组中，每个结点的数据域中有两个指针，分别指向第一个长子和它右侧的兄弟。    
![](https://i.imgur.com/i0s5hrE.png)        
这种表示法如果要找到双亲还需要再添加指针域指向双亲，不过这种表示法将复杂树转为了二叉树，这样可以利用二叉树的特性和算法来处理相应的操作。     

**二叉树**        
由n个结点构成的有限集，当n=0时，为空树，当n>0时，由一个根结点和两颗互不相交的，分别称为根结点的左子树和右子树的二叉树构成。    

二叉树特点：         


- 每个结点**最多**只有两颗子树，二叉树中不存在度大于2的结点，可以是两颗子树，也可以是一颗或者没有子树。      
- 左子树和右子树有顺序，次序不能任意颠倒。        
- 即使树中某结点只有一棵子树，也要区分是左子树还是右子树。      

二叉树的五种基本形态：      


- 空二叉树
- 只有一个根结点
- 根结点只有左子树
- 根结点只有右子树
- 根结点既有左子树又有右子树       

特殊二叉树：       


- 斜树        
所有结点都只有左子树的二叉树称为左斜树，所有结点都有右子树的二叉树称为右斜树。斜树的结点数即为该树的深度。      


- 满二叉树  
一颗二叉树中，所有分支的结点都存在左子树和右子树，并且所有的叶子都在同一层上，这样的二叉树称为满二叉树。     
**满二叉树特点**     
叶子只能出现在最下一层        
非叶子的结点的度一定是2
同样深度的树中，满二叉树的结点个数最多，叶子数最多。    

- 完全二叉树       
对一颗n各结点的二叉树按层序编号，若编号为i的结点与对应深度的满二叉树中的编号一致，则这样的二叉树称为完全二叉树。即满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。完全二叉树是满二叉树的子集。       
**完全二叉树特点**       
叶子结点只能是最下两层        
最下层的叶子一定集中在左部连续位置      
倒数第二层，若有叶子结点，一定都在右部连续位置     
如果结点的度为1，该结点只有左孩子，不存在只有右子树的情况        
同样结点数的二叉树，完全二叉树的深度最小    

**二叉树的性质**      


- 在二叉树的第i层上至多有2^(i-1)个结点        
- 在深度为k的二叉树中，结点数最多为2^k - 1   
- 对于任何一个二叉树，终端结点数N0=N2+1(N2:度为2的结点)       
- 对于一颗**完全二叉树**，树的深度值为[log2N]+1 (N为结点数，[]为不大于该值的最大整数)         
- 对于一颗有n个结点的**完全二叉树**（深度为[log2N]+1）的结点按层序编号，对于任一结点i:   
1.若i=1,则结点i为根结点，无双亲；若i>1，双亲结点的编号为[i/2]     
2.若2i>n，则结点无左孩子，否则左孩子结点为2i        
3.若2i+1>n，则结点无右孩子，否则右孩子结点为2i+1           

**二叉树的存储结构**        
二叉树的特殊性可以使用顺序结构存储按层序编号的结点，不存在的结点需要在数组对应编号处空缺。极端情况下，一颗深度为k的右斜树结点数为k，但需要 2^k - 1个存储单元。一般顺序存储结构适用于完全二叉树。        
使用链式存储结构，设计一个数据域和两个指针域的结点链表来存储二叉树，这样的链表叫做二叉链表，如有必要可以再添加指向双亲的指针域，为三叉链表。     

**二叉树的遍历**        
二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。        
如果限制遍历方向从左向右，主要分为四种遍历方法：          
![](https://i.imgur.com/BGX5deh.png)          
**1.前根序遍历**                    
 规则：二叉树为空，则空操作返回，否则先遍历根结点，然后遍历左子树，最后遍历右子树。   
ABDHECFG           
**2.中根序遍历**       
规则：二叉树为空，则空操作返回，否则先遍历左子树，然后遍历根结点，最后遍历右子树。         
HDBEAFCG            
**3.后根序遍历**     
规则：二叉树为空，则空操作返回，否则先遍历左子树，然后遍历右子树，最后遍历根结点。       
HDEBFCGA       
**4.层序遍历**       
规则：二叉树为空，则空操作返回，否则按照层序从左至右依次访问结点。         

二叉树的定义和遍历采用递归的方式 
二叉树链表结构及遍历实现：        

	#define OK 1
	#define ERROR 0
	#define TRUE 1
	#define FALSE 0

	#define MAXSIZE 100

	typedef int Status;

	//用于构造二叉树的全局变量
	int index = 1;
	typedef char String[24];
	String str; //字符数组的别名    

	Status StrAssign(String T, char *chars) {
	int i;
	if (strlen(chars) > MAXSIZE)
		return ERROR;
	else {
		T[0] = strlen(chars);
		for (i = 1; i <= T[0]; i++)
			T[i] = *(chars + i - 1);
		return OK;
	}
	}

	typedef char TElemType;
	TElemType Nil = ' ';

	Status visit(TElemType e) {
	printf("%c", e);
	return OK;
	}

	typedef struct BiTNode {
	TElemType data;
	struct BiTNode *lchild, *rchild;
	}BiTNode, *BiTree;

	Status InitBiTree(BiTree *T) {
	*T = NULL;
	return OK;
	}

	//销毁二叉树
	void DestroyBiTree(BiTree *T) {
	if (*T) {
		if ((*T)->lchild)
			DestroyBiTree(&(*T)->lchild);
		if ((*T)->rchild)
			DestroyBiTree(&(*T)->rchild);
		free(*T);//释放结点空间
		*T = NULL;
	}
	}

	void CreatBiTree(BiTree *T) {
	TElemType ch;
	ch = str[index++];
	if (ch == '#')
		*T = NULL;
	else {
		*T = (BiTree)malloc(sizeof(BiTNode));
		if (!T)
			exit(OVERFLOW);
		//使用前根序的次序创建二叉树
		(*T)->data = ch;
		CreatBiTree(&(*T)->lchild);   //构造左子树
		CreatBiTree(&(*T)->rchild);   //构造右子树
	}
	}

	Status BiTreeEmpty(BiTree T) {
	if (T)
		return FALSE;
	else
		return TRUE;
	}

	int BiTreeDepth(BiTree T) {
	int i, j;
	if (!T)
		return 0;
	if (T->lchild)
		i = BiTreeDepth(T->lchild);
	else
		i = 0;
	if (T->rchild)
		j = BiTreeDepth(T->rchild);
	else
		j = 0;
	return i > j ? i + 1 : j + 1;
	}

	TElemType Root(BiTree T) {
	if (BiTreeEmpty(T))
		return Nil;
	else
		return T->data;
	}

	TElemType Value(BiTree p) {
	return p->data;
	}

	void Assign(BiTree p, TElemType e) {
	p->data = e;
	}


	//二叉树前根序遍历
	void PreOrderTraverse(BiTree T) {
	if (T == NULL)
		return;
	printf("%c", T->data);                    //先显示结点数据
	PreOrderTraverse(T->lchild);       //再遍历左子树
	PreOrderTraverse(T->rchild);      //再遍历右子树
	}

	//二叉树中根序遍历
	void InOrderTraverse(BiTree T) {
	if (T == NULL)
		return;
	InOrderTraverse(T->lchild);       //先遍历左子树
	printf("%c", T->data);                //再显示结点数据
	InOrderTraverse(T->rchild);      //再遍历右子树
	}

	//二叉树后根序遍历
	void PostOrderTraverse(BiTree T) {
	if (T == NULL)
		return;
	PostOrderTraverse(T->lchild);  //先遍历左子树
	PostOrderTraverse(T->rchild);  //再遍历右子树
	printf("%c", T->data);                //显示结点数据
	}


	int main()
	{
	int i;
	BiTree T;
	TElemType e1;
	InitBiTree(&T);

	StrAssign(str, "ABDH#K###E##CFI###G#J##");

	CreatBiTree(&T);

	printf("构造空二叉树后，树空否？%d(0:否,1:是) 树的深度=%d\n", BiTreeEmpty(T), BiTreeDepth(T));
	e1 = Root(T);
	printf("二叉树的根结点:%c\n",e1);

	printf("二叉树前根序排列:\n");
	PreOrderTraverse(T);
	printf("\n二叉树中根序排列:\n");
	InOrderTraverse(T);
	printf("\n二叉树前跟序排列:\n");
	PostOrderTraverse(T);
	
	getchar();
	return 0;
	}
      
**二叉树遍历性质**        

- 已知前根序和中根序，可以唯一确定一颗二叉树
- 已知后根序和中根序，可以唯一确定一颗二叉树            

**线索二叉树**         
利用二叉链表中的空指针域存放指向结点在某种次序下的前驱和后继结点的地址，将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。      
线索二叉树中需要解决的一个问题是，如何知道一个结点的左指针域是指向其左孩子还是指向该结点的前驱，或者右指针域指向其右孩子还是该结点的后继，因此线索二叉树需要对原结点添加两个标志位，ltag和rtag，标志位只存储0和1,0表示指向其对应的孩子，1表示为对应前驱或后继。    

线索二叉树实现：   

	typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
	typedef char TElemType;
	typedef enum {Link,Thread} PointerTag;	/* Link==0表示指向左右孩子指针, */
										/* Thread==1表示指向前驱或后继的线索 */
	typedef  struct BiThrNode	/* 二叉线索存储结点结构 */
	{
	TElemType data;	/* 结点数据 */
	struct BiThrNode *lchild, *rchild;	/* 左右孩子指针 */
	PointerTag LTag;
	PointerTag RTag;		/* 左右标志 */
	} BiThrNode, *BiThrTree;

	TElemType Nil='#'; /* 字符型以空格符为空 */

	Status visit(TElemType e)
	{
	printf("%c ",e);
	return OK;
	}

	/* 按前序输入二叉线索树中结点的值,构造二叉线索树T */
	/* 0(整型)/空格(字符型)表示空结点 */
	Status CreateBiThrTree(BiThrTree *T)
	{ 
	TElemType h;
	scanf("%c",&h);

	if(h==Nil)
		*T=NULL;
	else
	{
		*T=(BiThrTree)malloc(sizeof(BiThrNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)->data=h; /* 生成根结点(前序) */
		CreateBiThrTree(&(*T)->lchild); /* 递归构造左子树 */
		if((*T)->lchild) /* 有左孩子 */
			(*T)->LTag=Link;
		CreateBiThrTree(&(*T)->rchild); /* 递归构造右子树 */
		if((*T)->rchild) /* 有右孩子 */
			(*T)->RTag=Link;
	}
	return OK;
	}

	BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 */
	/* 中序遍历进行中序线索化 */
	void InThreading(BiThrTree p)
	{ 
	if(p)
	{
		InThreading(p->lchild); /* 递归左子树线索化 */
		if(!p->lchild) /* 没有左孩子 */
		{
			p->LTag=Thread; /* 前驱线索 */
			p->lchild=pre; /* 左孩子指针指向前驱 */
		}
		if(!pre->rchild) /* 前驱没有右孩子 */
		{
			pre->RTag=Thread; /* 后继线索 */
			pre->rchild=p; /* 前驱右孩子指针指向后继(当前结点p) */
		}
		pre=p; /* 保持pre指向p的前驱 */
		InThreading(p->rchild); /* 递归右子树线索化 */
	}
	}

	/* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */
	Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)
	{ 
	*Thrt=(BiThrTree)malloc(sizeof(BiThrNode));
	if(!*Thrt)
		exit(OVERFLOW);
	(*Thrt)->LTag=Link; /* 建头结点 */
	(*Thrt)->RTag=Thread;
	(*Thrt)->rchild=(*Thrt); /* 右指针回指 */
	if(!T) /* 若二叉树空,则左指针回指 */
		(*Thrt)->lchild=*Thrt;
	else
	{
		(*Thrt)->lchild=T;
		pre=(*Thrt);
		InThreading(T); /* 中序遍历进行中序线索化 */
		pre->rchild=*Thrt;
		pre->RTag=Thread; /* 最后一个结点线索化 */
		(*Thrt)->rchild=pre;
	}
	return OK;
	}

	/* 中序遍历二叉线索树T(头结点)的非递归算法 */
	Status InOrderTraverse_Thr(BiThrTree T)
	{ 
	BiThrTree p;
	p=T->lchild; /* p指向根结点 */
	while(p!=T)
	{ /* 空树或遍历结束时,p==T */
		while(p->LTag==Link)
			p=p->lchild;
		if(!visit(p->data)) /* 访问其左子树为空的结点 */
			return ERROR;
		while(p->RTag==Thread&&p->rchild!=T)
		{
			p=p->rchild;
			visit(p->data); /* 访问后继结点 */
		}
		p=p->rchild;
	}
	return OK;
	 }	

	 int main()
	{
	BiThrTree H,T;
	printf("请按前序输入二叉树(如:'ABDH##I##EJ###CF##G##')\n");
 	CreateBiThrTree(&T); /* 按前序产生二叉树 */
	InOrderThreading(&H,T); /* 中序遍历,并中序线索化二叉树 */
	printf("中序遍历(输出)二叉线索树:\n");
	InOrderTraverse_Thr(H); /* 中序遍历(输出)二叉线索树 */
	printf("\n");
	
	return 0;
	}		

如果所用二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，可以采用线索二叉链表的存储结构           

### 图 ###
图是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图中的顶点的集合，E是图G中边的集合。         

- 线性表中的数据元素叫元素，树中的数据元素叫结点，图中的数据元素叫顶点。
- 线性表中可以没有元素，叫空表，树中可以没有结点，叫空树，而图中不能没有顶点，在定义中，V是顶点的集合，有穷且非空。
- 线性表中，相邻的数据元素具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。    

关于图的各种定义：       
**无向边&无向图**             
若顶点Vi到顶点Vj之间的边没有方向，则称这条边为无向边，用无序偶对（Vi，Vj）来表示。如果任意两个顶点之间的边都是无向边，则称该图为无向图。无向图表示法：G=（V1，{E1}），其中V1={A,B,C,D}，E1={（A,B），（B,C），（C,D），（A,C）} (**无向边小括号**)        

**有向边&有向图**       
若顶点Vi到顶点Vj的边有方向，称该边为有向边，也叫作**弧**。使用有序偶<Vi,Vj>表示，Vi为弧尾，Vj为弧头。如果任意两个顶点之间的边为有向边，则称该图为有向图。有向图的表示法：G=（V2，{E2}），其中V2={A,B,C,D}，E2={<A,D>,<B,C>,<C,A>,<B,A>}   ( **有向边尖括号**)         

**相关术语**         
在图中，如果不存在顶点到自身的边，且同一条边不重复再出现，则称该图为 **简单图**            

在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。n的顶点的无向完全图的边的数目：n*(n-1)/2           

在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。n个顶点的有向完全图的弧的数目：n*(n-1)        

有些图的边或弧具有与他相关的数字，这种与图的边或弧相关的数叫做**权**，带权的图通常称为 **网**。      

图G=（V，{E}），图G'=(V'，{E'})，且 V属于V’，E属于E'，称G为G'的子图。     

无向图中，顶点v的度为与该顶点相关联的边的数目，即为TD（v）。图中边的数目为各顶点的度的和的一半。    

有向图中，顶点v的度为入度和出度之和，入度为以顶点V为头的弧，记作ID（v），出度为以顶点V为尾的弧，记作OD（v）。有向图中的边的数目为顶点的ID（v）,或者OD（v）。      

图中顶点V到顶点V'之间的路径为顶点的序列，对于无向图该序列中相邻的点之间的边属于无向图的边的集合，对于有向图该序列中的相邻点组成的具有方向性，属于有向图的弧的集合。**路径的长度为弧或边的数目。**           

**连通图相关术语**            
在无向图中，如果顶点V到顶点V'有路径，称为V和V'是连通的。如果对于图中任意两个顶点都是连通的，则称该图为连通图。         

无向图中的极大连通子图称为连通分量，连通分量强调：             

- 要是子图       
- 子图要是连通的       
- 连通子图含有极大顶点数         
- 具有极大顶点数的连通子图包含依附于这些顶点的所有边         

而有向图中，如果对于每一对属于顶点集的Vi，Vj，从Vi到Vj和从Vj到Vi都存在路径，则称该有向图为强连通图，有向图中的极大强连通子图称作有向图的强连通分量。     

**连通图的生成树**        
一个连通图的生成树是一个极小的连通子图，含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。     
        
如果一个有向图恰有一个顶点的入度为0，其他顶点的入度均为1，则是一棵有向树。一个有向图由若干有向树构成森林。         

**图的抽象数据类型**                   
![](https://i.imgur.com/Uc5leta.png)          

**图存储结构**  
               
- **邻接矩阵**         
图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（为邻接矩阵）存储图中的边或弧的信息       
无向图：         
![](https://i.imgur.com/dW3XK20.png)             
有向图：         
![](https://i.imgur.com/zKfevoN.png)          
无向图的邻接矩阵是对称阵，有向图的邻接矩阵不一 定是对称阵        
网中存储权值：         
![](https://i.imgur.com/U9ASSlh.png)          
![](https://i.imgur.com/bsOMUo9.png)             

- **邻接表**         
对于边数相对于顶点较少的图，使用邻接矩阵会对存储空间造成一定的浪费。这时可以采用将数组与链表相结合的存储方式，称为邻接表。              
顶点数组中存储顶点信息和一个指向第一个邻接点的指针，边表结点由存储某顶点的下标和边表中下一个结点的指针域构成           
无向图邻接表            
![](https://i.imgur.com/U7v5WIp.png)         
有向图邻接表             
![](https://i.imgur.com/2gbNZtP.png)                 
有向图有方向，边表中可以按照以该顶点的弧尾储存，或者弧头存储             
带权值的网图：                   
![](https://i.imgur.com/2VSvK3R.png)                
边表再添加权值域存储权值          

- **十字链表**           
对于有向图来说，邻接链表是有缺陷的。关心出度问题，想了解入度情况，需要遍历整个图。将邻接链表和逆邻接链表结合。         
顶点数组的数据元素除了数据域和出度指针域外，添加入度指针域，即指向弧头为该顶点的弧边结点         
弧边结点为两个数据域两个指针域，数据域分别记录该弧的弧头和弧尾的顶点下标，指针域一个指向顶点出度的弧，一个指向顶点入度的弧       
![](https://i.imgur.com/4pstVoa.png)             
十字链表将邻接表和逆邻接表结合，可以方便找出某一个顶点的入度和出度的弧，因此在有向图中，十字链表是非常好的数据结构。      


- **邻接多重表**       
对于无向图的邻接表，若关注的重点是顶点，那么邻接表可以满足要求，若是更关注边的操作，如对已访问的边做标记，删除一条边等，那么使用邻接表就会相对比较麻烦，要找到这条边对应的两个节点进行处理。使用邻接多重表结构：          
| ivex | ilink | jvex | jlink |         
ivex和jvex是与某条边依附的两个顶点在顶点表中的下标，ilink是顶点ivex所指的下一条边，jlink是顶点jvex所指的下一条边，在构造图的边结点时采用头插法，这样每个边结点会被两个指针所指：        
![](https://i.imgur.com/6jXbAOr.png)                      


- **边集数组**        
边集数组有两个一维数组构成。一个存储顶点信息，一个存储边的信息，边数组的每个数据元素由每条边的起点下标和终点下标以及权重组成。边集数组关注的是边的集合，边集数组中查找顶点的度需要扫描整个边数组，效率不高，更适合对边依次处理的操作，不适合对顶点的相关操作。         
![](https://i.imgur.com/lhqVqpe.png)              

**图的遍历**           
从图中某一顶点出发访遍图中其与顶点，且使每一个顶点仅被访问一次，该过程叫做图的遍历            

**深度优先遍历DFS**                
也称为深度优先搜索，简称DFS。从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。这里是对于连通图，若是非连通图，则对其连通分量扥别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。       
深度优先其实就是一个递归过程，类似一棵树的前根序遍历过程。         

**广度优先遍历BFS**        
广度优先搜索类似于树的层序遍历，将与该顶点的邻接的顶点通过入队和出队，完成层序搜索。       

深度优先适合有明确的目标，以找到目标为主要目的的情况，而广度优先适合在不断扩大搜索范围以找到相对最优解的情况。         

**最小生成树**         
一个连通图的生成树是一个极小的连通子图，包含图中所有的顶点，只有足以构成一棵树的n-1条边。构造连通网的最小代价生成树称为最小生成树。找出最小生成树的常用算法：               
![](https://i.imgur.com/dfGhCsm.png)           
**Prim算法**           
Prim算法从某一顶点开始            

- 遍历该顶点与其他顶点的之间的边的权值，并存入权值数组      
- 并找出其中权值最小的边的对应顶点，记录下该顶点下标      
- 同时将最小权值的边的两个顶点做标记，避免重复检索           
- 将记录的顶点与其他顶点的权值与之前的权值数组比较
- 更新权值数组，记录下两者中较小的权值，如果有更新将记录的顶点的下标存入对应位置的下标数组

这样一轮检测完时，权值数组中储存的权值表示与当前权值最小的边的顶点有邻接关系的顶点对应的边的权值，下标数组中存储的是与当前权值最小的边的其中一个顶点邻接的未检索的其他顶点。对其他顶点重复进行上述操作，时间复杂度为0(n^2)，针对上图的Prim算法结果：              
![](https://i.imgur.com/Yalm1mJ.png)              

**Kruskal算法**         
Kruskal算法从边开始，依次选择权值最小的边来构成最小生成树，比较重要的两步：          

-  将边按照权值进行排序，从权值最小的边开始           
-  检查被选择的边是否构成环路，如没有构成环路，则记录边的顶点下标，否则放弃这条边           

因此，针对上图首先按照权值对边进行排序，得到：       
![](https://i.imgur.com/T5TzfrW.png)            
使用Kruskal算法结果：        
![](https://i.imgur.com/2aytyLO.png)                 
该算法与边有关，与判断环路相关的函数时间复杂度为loge ，对e条边的总体时间复杂度为O(eloge)                

对比两个算法，Kruskal算法针对边展开，对于稀疏图Kruskal的效率会相对较高，而对于稠密图，即边比较多的情况下，Prim算法效率相对较高。    


   





      
                  

              






 
