## 设计模式笔记 ##
### UML类图 ###
![](https://i.imgur.com/hGOUFKY.png)        
“动物矩形框”代表类，类图分三层：         
第一层：类名（如果为抽象类，则用希斜体表示）        
第二层：类的特性，通常为字段和属性       
第三层：类的操作，通常为方法或行为        
成员前 + 表示为public; - 表示为 private; # 表示为 protected       

“飞翔矩形框”代表借接口 ，分为两层：   
第一层：接口名称 带有 interface    
第二层：接口方法        
接口另一种标识方法：棒棒糖表示法   （讲人话接口）        

**类之间的继承关系用**：空心三角形+实线表示       
**接口的实现关系**：空心三角形+虚线表示       
**关联关系**：实线箭头表示（关联关系：一个类的实现需要知道另一个类）     
**聚合关系**：空心菱形+实线箭头（聚合关系：代表一种“弱拥有关系”，对象A可以包含B，但B对象不是A的一部分）     
**组合关系**：实心菱形+实线箭头（组合关系：代表一种”强拥有关系“，严格体现部分与整体的关系，且部分与整体具有相同的生命周期，例如 鸟与翅膀，组合关系两端的连线会有数字，表明对应端的类可以有几个实例）                  
**依赖关系**：通过虚线箭头表示（依赖关系：一个类的实现依赖于另一个类）           

### 1. 简单工厂模式 ###
简单工厂模式：通过一个单独的类来管理类的实例化过程，这个类充当“工厂”角色，负责生产产品。         
![](https://i.imgur.com/LZKmGX1.png)         
这里的OperationFactory(提供了CreateOperation静态方法)负责管理Operation的子类实例化过程，通过多态，返回父类的方式，充当工厂角色。当有新的操作产生，添加相应的Operation子类，并在OperationFactory中的CreateOperation方法中添加相应的对象生成过程。           
### 2.策略模式 ###
策略模式：定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。       
![](https://i.imgur.com/m0R8zz1.png)       
策略模式是一种定义一系列算法的方法，从概念上看，所有的算法完成相同的工作，只是实现方式不同，策略模式以相同的方式（这个相同的方式是通过Context类中提供的算法共同的行为）调用所有的算法，减少各种算法与使用算法之间的耦合程度。      
策略模式中的Strategy类层次为Context定义了一系列供重用的算法或行为，继承有助于提取出这些算法中的公共功能。     
同时，策略模式简化了单元测试，每一个算法都有自己的类，可以对自己的接口进行单独测试。                         
![](https://i.imgur.com/rvp2hit.png)       
基本的策略模式中，选择所用算法的具体实现的职责由客户端承担，并转给Context对象，而将策略模式与简单工厂模式相结合后，选择的具体实现职责可以由Context对象来承担，减轻客户端的职责。                           
将简单工厂模式与策略模式相结合，这样可以避免在使用这些行为的类中（此例中为客户端）进行条件判断语句。策略模式将这种变化的选择过程进行了封装。        
同时在此例中通过Context类管理超类的一个实例，客户端只需知道Context一个类即可，而无需像简单工厂模式需要知道超类和工厂类，Context对Strategy不同对象的生成再次进行了封装，因此，客户端只需知道Context一个类。             
### 3.单一职责原则 ###
就一个类而言，应该仅有一个引起它变化的原因。          
如果一个类承担的职责过多，就等于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。         
如果改变一个类的动机多于一个 ，则这个类就具有多于一个职责，则应该考虑职责分离。     
### 4.开放-封闭原则 ###
开放-封闭原则，是说软件实体（类，函数，模块等）应该可以扩展，但是不可修改。**对于扩展是开放的，对于修改是封闭的**。      
在最初编写代码时，假设变化不会发生，当变化发生时，创建抽象来隔离以后发生的同类变化。面对需求，对程序的改动是通过增加新代码进行，而不是更改该现有代码。        
例如，面对加法需求的时候，可以在Client只写一个加法类，而当增加更多运算的需求时，则需要通过继承和多态来隔离具体的运算过程与Client的耦合程度。           
![](https://i.imgur.com/qD7KSKl.png)              
### 5.依赖倒转原则 ###
依赖倒转原则，抽象不应该依赖细节，细节应该依赖抽象。针对接口编程，而不是针对实现编程。      
不管是高层模块还是低层模块，都应依赖于抽象，即接口或抽象类，只要接口是稳定的，任何一个更改都不用担心其他受到影响，这样高层和低层模块都可以很容易被复用。       
**里氏代换原则**      
一个软件实体使用的是一个父类的话，那么一定适用其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件中，把父类都替换成子类，程序的行为没有变化，简单来讲，子类必须要能够替换掉父类。            
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，子类也能够在父类基础上增加新的行为。        

对此，高层模块和底层模块之间不应该直接依赖，而是通过接口或抽象类          
 ![](https://i.imgur.com/BOM7TKB.png)        
### 6.装饰模式 ###
装饰模式，动态给对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。          
![](https://i.imgur.com/wgzFVED.png)              
Component定义一个对象接口，可以动态给对象添加功能。ConcreteComponent是一个实体对象，也可以为这个对象添加职责。Decorator，装饰的抽象类，继承了Component，Component（或者说ConcreteComponent）通过装饰抽象类来进行功能的扩展，对于Component类来说并不需要知道Decorator的存在。ConcreteDecorator具体的起装饰作用的对象，为Component添加功能。          
如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样，如果只有一个ConcreteDecorator类，那么就没有必要建立单独的Decorator类，而是将Decorator和ConcreteDecorator责任合并成一个类。        

装饰模式将要装饰的功能单独放在特定的类中，让这个类包装所要装饰的对象，因此，当需要执行特殊行为时，客户代码根据需要**有选择，按顺序**的使用装饰功能包装对象。         
### 7.代理模式 ###
代理模式：为其它对象提供一种代理以控制对该对象的访问。   
![](https://i.imgur.com/M8XK1OS.png)       
代理类通过实现和被代理类完全相同的接口并管理一个被代理类的实例，使在使用被代理对象的地方完全替代被代理对象。    
代理模式的应用场合：      
1. 远程代理。为一个对象在不同的地址空间提供局部代理，这样可以隐藏一个对象存在于不同地址空间的事实。  
2. 虚拟代理。根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。          
3. 安全代理。用来控制对真实对象访问得权限。      
4. 智能指引。当调用真实对象时，代理处理另外一些事。比如在计算真实对象的引用次数，当引用次数为0时，自动释放真实对象；或当第一次引用持久化对象时，将其装入内存；通过代理在访问一个对象时附加一些内务处理。         

### 8.工厂方法模式 ###
简单工厂模式的优点在于工厂类中包含必要的逻辑判断，根据客户端的选择动态实例化相关的类，对于客户端来说，去除了对产品本身的依赖。而如果此时对产品类进行扩展的话，简单工厂中的代码就要进行修改，而不是添加新的类来进行扩展，这样违背了“开放-封闭原则”，因此有工厂方法模式。   
工厂方式模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。     
工厂方法最终是创建出产品，即实例化的对象。         
![](https://i.imgur.com/DKCDLdq.png)                   
工厂方法克服了简单工厂模式所违背的“开放-封闭原则”，同时对对象的创建过程进行了封装。，工厂方法模式是对简单工厂模式的抽象和修改。但缺点在于，当增加一个产品时，需要增加新的工厂类与之对应。         

### 9.原型模式 ###
原型模式：通过原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，而不是通过实例化的方式。        
![](https://i.imgur.com/WcC79tc.png)                   
在原型模式中涉及到一个方法：        
object.MemberwiseClone()      
创建当前对象的**浅表副本**，即创建一个新的对象，将当前对象的非静态字段复制到该新对象。如果成员为值类型，则执行逐位复制，而如果是引用类型成员，则是复制引用而不是复制引用的对象。       
原型模式中的原型抽象类一般用不着，.NET在System命名空间中提供了ICloneable接口，实现该接口即可完成对应的原型。       
**浅复制**：被复制的对象所有的变量与原来对象的值相同，而所有对其他对象的引用仍然指向原来的对象，而不是引用对象的副本。       
**深复制**：深复制将引用对象的变量指向引用对象复制过的新对象，而不是指向原有的引用对象本身。       
### 10.模板方法模式 ###
模板方法模式：定义一个操作中算法的骨架部分，而将一些步骤延迟到子类当中。模板方法使得子类可以不改变一个算法的结果即可重定义该算法的某些特定步骤。          
当要完成在某一细节层次一致的一个过程或一系列步骤，但其中个别步骤更详细的层次上的细节可能不同时，通常考虑使用模板方法模式来处理。         
![](https://i.imgur.com/NnJKXSY.png)                  
AbstractClass定义实现了一个模板方法。模板方法一般是一个具体的方法，给出顶层逻辑的骨架，逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。     
模板方法通过把不变的行为提取到超类，而将变化的细节推迟到子类中去实现，形成较好的代码复用。   
### 11.迪米特法则 ###
如果两个类之间不必彼此通信，那么这两个类不应该发生直接相互作用。如果一个类需要调用另一个类的某一个方法，可以通过第三者转发调用。   
在类的设计结构上，每一个类应该尽量降低成员的访问性，不需要让其他类知道的字段或行为就不必要公开。   
迪米特法则旨在降低类与类之间的耦合性，耦合越弱，越有利于复用，处于弱耦合中的类发生修改，不会对现有关系造成强干扰。       
### 12.外观模式 ###
外观模式：为子系统中一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使子系统更加容易使用。     
![](https://i.imgur.com/dvFMIAx.png)         
外观模式可以为复杂子系统提供简单接口，使耦合性降低。      
### 13.建造者模式 ###
建造者模式：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。     
建造者模式将一个产品的内部表象与产品的生成过程分割开来，使一个建造过程具有不同的内部表象的产品对象。用户只需指定需要建造的类型即可，无需关心建造的过程和细节。      
![](https://i.imgur.com/8TrvJVq.png)                  
Builder:指定创建Product的算法,规程           
ConcreteBuilder:按照规程创建Product具体实施者      
Product:具体产品    
Director:指挥者,确定建造过程按照规程实施      

以盖房子为例，Builder实际上是施工图纸，施工规程；ConcreteBuilder为建筑工人，每个阶段按照施工图纸要求进行操作；     
Director实际上为施工监理，确保工人们的操作次序是符合规程的；   
Product就是具体的楼房了    

建造者模式是在当创建复杂对象的算法应该独立于对象的组成部分以及装配过程时适用的模式。        
### 14.观察者模式 ###
观察者模式定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使他们更够自动更新自己。          
观察者模式又称：发布-订阅模式         
![](https://i.imgur.com/MhQ4xoD.png)          
根据依赖倒转原则，这里的主题类和观察者基类是对具体类的抽象，使得实体类针对抽象编程，降低耦合性。     
观察者模式所做的工作其实是在解除耦合，让耦合的双方都依赖于抽象而不是具体。       

### 15.抽象工厂模式 ###
抽象工厂模式（Abstract Factory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。      
![](https://i.imgur.com/OP33485.png)           
抽象工厂与工厂方法模式相比，增加了产品的系列化，同时工厂类中提供了系列产品的生产过程。同时由于同系列产品的差异，对同系列产品增加了一层抽象，同系列的不同产品在不同工厂实例类生产。        
抽象工厂模式易于交换产品系列，由于具体工厂类，如    

		AbstractFactory factory=new ConcreteFactory1();         
在一个应用中只需要在初始化时出现一次，使得改变一个应用的具体工厂比较容易，改变具体的工厂即可使用不同系列的产品配置。      
同时，抽象工厂模式使具体创建实例的过程与客户端分离，客户端通过抽象接口操纵实例，产品的具体类名被其他具体工厂实现分离，不会出现在客户端代码中。        
**抽象工厂模式也存在缺点**      
如果要增加新的产品系列，需要添加产品系列类，同时需要对抽象工厂基类和实例类增加相应的产生生产方法。         
**通过简单工厂克服抽象工厂模式缺点**        
![](https://i.imgur.com/jXIzmQw.png)           
这里为了避免在添加新的产品系列同时需要增加抽象工厂类，使用简单工厂模式，将产品的生产和判断放入DataBase类中。       
**通过反射技术消除判断过程**            
通过反射技术来实例化一个对象：          
	
	//需要引入 System.Reflection
	Assembly.Load("程序及名称").CreateInstance("命名空间.类名称")  
例如：      
	
	//常规实例化方法
	IUser result=new SqlServerUser();
	//使用反射实例化
	IUser result=(IUser)Assembly.Load("抽象工行模式").CreateInstance("抽象工厂模式.SqlserverUser")         
这样客户端的代码可以保持一致，如果要更改产品系列，只需将传入的className字符串更改即可，如果使用配置文件，将字符串存储在配置文件中，可以只修改配置文件的内容，而无需修改源代码编译。          
	
	private static readonly string db =ConfigurationSettings.AppSettings["DB"];           

### 16.状态模式 ###
状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。     
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑装移到表示不同状态的一系列类当中，可以将复杂的判断逻辑简化。       
![](https://i.imgur.com/phxq1uz.png)                      
状态模式能将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。       
将特定的状态相关的行为及状态转换的属性放入一个对象中，所有与状态相关的代码都放入ConcreteState中，通过定义新的子类可以很容易的增加新的状态和转换。        
状态模式通过将各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。         
当一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变其行为时，可以考虑使用状态模式。      

### 17.适配器模式 ###
适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。         
当系统的数据和行为都正确，但接口不符，可以考虑适配器模式，目的是使控制范围之外的原有对象与某个接口匹配。适配器模式主要应用于希望用一些现存的类，但是接口又与复用环境要求不一致的情况    
![](https://i.imgur.com/b6wdWFU.png)                

### 18.备忘录模式 ###
备忘录模式（Memento）:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。     
![](https://i.imgur.com/E9Ck2C9.png)                         
**Originator（发起人）**：负责创建一个备忘录Memento,用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。           
**Memento（备忘录）**：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。Memento类实际上对要保存的内容进行了封装。      
**Caretaker（管理者）**：负责保存好备忘录Memento的实例，不能对备忘录的内容进行操作或检查。             

### 19.组合模式 ###
组合模式：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。        
![](https://i.imgur.com/hdYj2Xp.png)        
**Component**为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件       
**Leaf**在组合中表示叶结点对象，叶结点没有子结点。       
**Composite**定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove         

当需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就可以考虑使用组合模式。     

### 20.迭代器模式 ###
迭代器模式，提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。      
![](https://i.imgur.com/P1oPLT6.png)       
迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部类透明的访问集合内部的数据。       
当需要访问一个聚集对象，而且不管这些对象是什么都需要便利的时候，可以考虑使用迭代器模式      
.NET中的迭代器实现是通过实现 IEnumerable 可枚举接口，返回 枚举器对象 IEnumerator 来实现     
详见  C[#迭代器——由foreach说开去](http://blog.csdn.net/u013477973/article/details/65635737)      

### 21.单例模式 ###
单例模式，保证一个类仅有一个实例，并提供一个访问他的全局访问点。           
通常可以通过一个全局变量使得一个对象被访问，但不能防止该对象被实例化多次。解决方式是，让类自身负责保存他的唯一实例，这个类可以保证没有其他实例可以被创建，并且对外提供一个访问唯一实例的方法。         
![](https://i.imgur.com/4mH5jZC.png)             
**多线程单例**        
在多线程程序中，多个线程同时访问Singleton类，调用GetInstance()方法，会有可能创建多个实例。可以通过给进程加一把锁。         

		public static Singleton GetInstace() {
            //对进程加锁，确保同一时刻只有一个进程进行对象实例的创建
            //lock:确保当一个线程位于代码的临界区时，另一个线程不进入临时区。如果其他线程试图进入锁定的代码
            //将会一直等待（即被阻止）直到该对象被释放
            if (instance == null) {
                //由于在加锁时instance对象实例还没有被创建，因此需要使用进程辅助对象syncRoot作为参数传入
                lock (syncRoot) {
                    //这里进行二次判断，是由于当实力没有被创建时，多个线程仍然可以进入第一层判断，被lock后
                    //第一个进程进入lock内，创建了实例后，为了防止在等待完成后进入lock内后续线程继续创建实例
                    //需要再次进行实例是否生成的判断
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }   

### 22.合成/聚合复用原则 ###
合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。        
**合成(Composition)**和**聚合(Aggregation)**都是关联的特殊种类。聚合表示一种弱的拥有关系,体现A对象可以包含B对象，但B对象可以不是A对象的一部分；合成是一种强的拥有关系，体现了严格的部分与整体的关系，部分与整体的生命周期一样。     

合成/聚合复用原则的好处在于，优先使用对象的合成/聚合将有助于保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模。并且不太可能增长为不可控制的庞然大物。      
继承是一种强耦合的结构，父类变，子类必须要变。         

### 23.桥接模式 ###
桥接模式，将抽象部分与他的实现部分分离，使它们都可以独立的变化。        
实现指的是抽象类和它的派生类用来实现自己的对象。     

桥接模式的核心意图是将这些实现独立出来，使其各自变化，这就使得每种实现的变化不会影响其他其他实现，从而达到对应变化的目的。      
![](https://i.imgur.com/Mx1MuMX.png)           
![](https://i.imgur.com/OYPSzjk.png)                        
桥接模式的“将抽象部分与实现部分分离”，即为实现系统可能有多角度分类，每一种分类都有变化，那么把这种多角度分离出来让他们独立变化，减少他们之间的耦合。                 

### 24.命令模式 ###
命令模式（Command）,将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作          
![](https://i.imgur.com/32QkACI.png)         
命令模式将命令抽象成类，通过多态将命令细分，命令指定命令的执行者，由中间对象对命令进行集中管理，解除调用者与实际执行者之间的耦合。       
命令模式的优点：       
1.比较容易地设计一个命令队列     
2.在需要的情况下，可以较为容易地将命令记入日志      
3.允许接受请求的一方决定是否要否决请求     
4.容易实现对命令的撤销和重做   
5.新增命令不影响其他类，新增具体命令类很容易       

### 25.职责链模式 ###
职责链模式：使多个对象都有机会处理请求，避免处理的发送者和接收者之间的偶合关系。将这个对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。     
![](https://i.imgur.com/8cXXNSl.png)                
职责链的好处：      
1.当客户提交一个请求时，请求是沿着链传递直至有一个ConcreteHandler对象负责处理        
2.接收者和发送者没有对方的明确信息，且链中的对象并不清楚完整的链结构。职责链简化对象之间的相互连接，只需保持一个指向后继者的引用     
3.客户端可以增加或修改请求的结构           

### 26.中介者模式 ###
中介者模式：使用一个中介对象来封装一系列对象之间的交互行为，中介者使各个对象之间不需要显示的进行相互引用，从而使其耦合松散，对于之间交互行为的更改可以由中介对象独立改变        
![](https://i.imgur.com/sFtMobq.png)       
中介者模式适用于一组对象已定义良好但是以复杂的方式进行通信的场合         

### 27.享元模式 ###
享元模式:运用共享技术有效地支持大量细粒度的对象         
![](https://i.imgur.com/ag42FDr.png)     
通过享元工厂来创建和管理共享对象的实例，而无需直接实例多个相同类的实例       
**内部状态&外部状态**       
享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的实例来表示数据，如果发现这些实例除了几个参数不一致外其它基本相同，可以考虑将参数移到类的外部，在方法调用时传递进来，就可以通过大幅度减少单个实例的数目。比如在围棋中，棋子的颜色可以作为内部状态，而棋子的位置坐标则可以看做是外部状态，这样享元工厂内的实例数目就为2个，而不通过享元模式对每一个棋子对象生成实例则需要361个空位。        


               


