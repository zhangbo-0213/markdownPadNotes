## 设计模式笔记 ##
### UML类图 ###
![](https://i.imgur.com/hGOUFKY.png)        
“动物矩形框”代表类，类图分三层：         
第一层：类名（如果为抽象类，则用希斜体表示）        
第二层：类的特性，通常为字段和属性       
第三层：类的操作，通常为方法或行为        
成员前 + 表示为public; - 表示为 private; # 表示为 protected       

“飞翔矩形框”代表借接口 ，分为两层：   
第一层：接口名称 带有 interface    
第二层：接口方法        
接口另一种标识方法：棒棒糖表示法   （讲人话接口）        

**类之间的继承关系用**：空心三角形+实线表示       
**接口的实现关系**：空心三角形+虚线表示       
**关联关系**：实线箭头表示（关联关系：一个类的实现需要知道另一个类）     
**聚合关系**：空心菱形+实线箭头（聚合关系：代表一种“弱拥有关系”，对象A可以包含B，但B对象不是A的一部分）     
**组合关系**：实心菱形+实线箭头（组合关系：代表一种”强拥有关系“，严格体现部分与整体的关系，且部分与整体具有相同的生命周期，例如 鸟与翅膀，组合关系两端的连线会有数字，表明对应端的类可以有几个实例）                  
**依赖关系**：通过虚线箭头表示（依赖关系：一个类的实现依赖于另一个类）           

### 1. 简单工厂模式 ###
简单工厂模式：通过一个单独的类来管理类的实例化过程，这个类充当“工厂”角色，负责生产产品。         
![](https://i.imgur.com/LZKmGX1.png)         
这里的OperationFactory(提供了CreateOperation静态方法)负责管理Operation的子类实例化过程，通过多态，返回父类的方式，充当工厂角色。当有新的操作产生，添加相应的Operation子类，并在OperationFactory中的CreateOperation方法中添加相应的对象生成过程。           
### 2.策略模式 ###
策略模式：定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。       
![](https://i.imgur.com/m0R8zz1.png)       
策略模式是一种定义一系列算法的方法，从概念上看，所有的算法完成相同的工作，只是实现方式不同，策略模式以相同的方式（这个相同的方式是通过Context类中提供的算法共同的行为）调用所有的算法，减少各种算法与使用算法之间的耦合程度。      
策略模式中的Strategy类层次为Context定义了一系列供重用的算法或行为，继承有助于提取出这些算法中的公共功能。     
同时，策略模式简化了单元测试，每一个算法都有自己的类，可以对自己的接口进行单独测试。                         
![](https://i.imgur.com/rvp2hit.png)       
基本的策略模式中，选择所用算法的具体实现的职责由客户端承担，并转给Context对象，而将策略模式与简单工厂模式相结合后，选择的具体实现职责可以由Context对象来承担，减轻客户端的职责。                           
将简单工厂模式与策略模式相结合，这样可以避免在使用这些行为的类中（此例中为客户端）进行条件判断语句。策略模式将这种变化的选择过程进行了封装。        
同时在此例中通过Context类管理超类的一个实例，客户端只需知道Context一个类即可，而无需像简单工厂模式需要知道超类和工厂类，Context对Strategy不同对象的生成再次进行了封装，因此，客户端只需知道Context一个类。             
### 3.单一职责原则 ###
就一个类而言，应该仅有一个引起它变化的原因。          
如果一个类承担的职责过多，就等于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。         
如果改变一个类的动机多于一个 ，则这个类就具有多于一个职责，则应该考虑职责分离。     
### 4.开放-封闭原则 ###
开放-封闭原则，是说软件实体（类，函数，模块等）应该可以扩展，但是不可修改。**对于扩展是开放的，对于修改是封闭的**。      
在最初编写代码时，假设变化不会发生，当变化发生时，创建抽象来隔离以后发生的同类变化。面对需求，对程序的改动是通过增加新代码进行，而不是更改该现有代码。        
例如，面对加法需求的时候，可以在Client只写一个加法类，而当增加更多运算的需求时，则需要通过继承和多态来隔离具体的运算过程与Client的耦合程度。           
![](https://i.imgur.com/qD7KSKl.png)              
### 5.依赖倒转原则 ###
依赖倒转原则，抽象不应该依赖细节，细节应该依赖抽象。针对接口编程，而不是针对实现编程。      
不管是高层模块还是低层模块，都应依赖于抽象，即接口或抽象类，只要接口是稳定的，任何一个更改都不用担心其他受到影响，这样高层和低层模块都可以很容易被复用。       
**里氏代换原则**      
一个软件实体使用的是一个父类的话，那么一定适用其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件中，把父类都替换成子类，程序的行为没有变化，简单来讲，子类必须要能够替换掉父类。            
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，子类也能够在父类基础上增加新的行为。        

对此，高层模块和底层模块之间不应该直接依赖，而是通过接口或抽象类          
 ![](https://i.imgur.com/BOM7TKB.png)        
### 6.装饰模式 ###
装饰模式，动态给对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。          
![](https://i.imgur.com/wgzFVED.png)              
Component定义一个对象接口，可以动态给对象添加功能。ConcreteComponent是一个实体对象，也可以为这个对象添加职责。Decorator，装饰的抽象类，继承了Component，Component（或者说ConcreteComponent）通过装饰抽象类来进行功能的扩展，对于Component类来说并不需要知道Decorator的存在。ConcreteDecorator具体的起装饰作用的对象，为Component添加功能。          
如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样，如果只有一个ConcreteDecorator类，那么就没有必要建立单独的Decorator类，而是将Decorator和ConcreteDecorator责任合并成一个类。        

装饰模式将要装饰的功能单独放在特定的类中，让这个类包装所要装饰的对象，因此，当需要执行特殊行为时，客户代码根据需要**有选择，按顺序**的使用装饰功能包装对象。         
### 7.代理模式 ###
代理模式：为其它对象提供一种代理以控制对该对象的访问。   
![](https://i.imgur.com/M8XK1OS.png)       
代理类通过实现和被代理类完全相同的接口并管理一个被代理类的实例，使在使用被代理对象的地方完全替代被代理对象。    
代理模式的应用场合：      
1. 远程代理。为一个对象在不同的地址空间提供局部代理，这样可以隐藏一个对象存在于不同地址空间的事实。  
2. 虚拟代理。根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。          
3. 安全代理。用来控制对真实对象访问得权限。      
4. 智能指引。当调用真实对象时，代理处理另外一些事。比如在计算真实对象的引用次数，当引用次数为0时，自动释放真实对象；或当第一次引用持久化对象时，将其装入内存；通过代理在访问一个对象时附加一些内务处理。         

### 8.工厂方法模式 ###
简单工厂模式的优点在于工厂类中包含必要的逻辑判断，根据客户端的选择动态实例化相关的类，对于客户端来说，去除了对产品本身的依赖。而如果此时对产品类进行扩展的话，简单工厂中的代码就要进行修改，而不是添加新的类来进行扩展，这样违背了“开放-封闭原则”，因此有工厂方法模式。   
工厂方式模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。     
工厂方法最终是创建出产品，即实例化的对象。         
![](https://i.imgur.com/DKCDLdq.png)                   
工厂方法克服了简单工厂模式所违背的“开放-封闭原则”，同时对对象的创建过程进行了封装。，工厂方法模式是对简单工厂模式的抽象和修改。但缺点在于，当增加一个产品时，需要增加新的工厂类与之对应。         

### 9.原型模式 ###
原型模式：通过原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，而不是通过实例化的方式。        
![](https://i.imgur.com/WcC79tc.png)                   
在原型模式中涉及到一个方法：        
object.MemberwiseClone()      
创建当前对象的**浅表副本**，即创建一个新的对象，将当前对象的非静态字段复制到该新对象。如果成员为值类型，则执行逐位复制，而如果是引用类型成员，则是复制引用而不是复制引用的对象。       
原型模式中的原型抽象类一般用不着，.NET在System命名空间中提供了ICloneable接口，实现该接口即可完成对应的原型。       
**浅复制**：被复制的对象所有的变量与原来对象的值相同，而所有对其他对象的引用仍然指向原来的对象，而不是引用对象的副本。       
**深复制**：深复制将引用对象的变量指向引用对象复制过的新对象，而不是指向原有的引用对象本身。       
### 10.模板方法模式 ###
模板方法模式：定义一个操作中算法的骨架部分，而将一些步骤延迟到子类当中。模板方法使得子类可以不改变一个算法的结果即可重定义该算法的某些特定步骤。          
当要完成在某一细节层次一致的一个过程或一系列步骤，但其中个别步骤更详细的层次上的细节可能不同时，通常考虑使用模板方法模式来处理。         
![](https://i.imgur.com/NnJKXSY.png)                  
AbstractClass定义实现了一个模板方法。模板方法一般是一个具体的方法，给出顶层逻辑的骨架，逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。     
模板方法通过把不变的行为提取到超类，而将变化的细节推迟到子类中去实现，形成较好的代码复用。   
### 11.迪米特法则 ###
如果两个类之间不必彼此通信，那么这两个类不应该发生直接相互作用。如果一个类需要调用另一个类的某一个方法，可以通过第三者转发调用。   
在类的设计结构上，每一个类应该尽量降低成员的访问性，不需要让其他类知道的字段或行为就不必要公开。   
迪米特法则旨在降低类与类之间的耦合性，耦合越弱，越有利于复用，处于弱耦合中的类发生修改，不会对现有关系造成强干扰。       
### 12.外观模式 ###
外观模式：为子系统中一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使子系统更加容易使用。     
![](https://i.imgur.com/dvFMIAx.png)         
外观模式可以为复杂子系统提供简单接口，使耦合性降低。      
### 13.建造者模式 ###
建造者模式：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。     
建造者模式将一个产品的内部表象与产品的生成过程分割开来，使一个建造过程具有不同的内部表象的产品对象。用户只需指定需要建造的类型即可，无需关心建造的过程和细节。      
![](https://i.imgur.com/8TrvJVq.png)                  
Builder:指定创建Product的算法,规程           
ConcreteBuilder:按照规程创建Product具体实施者      
Product:具体产品    
Director:指挥者,确定建造过程按照规程实施      

以盖房子为例，Builder实际上是施工图纸，施工规程；ConcreteBuilder为建筑工人，每个阶段按照施工图纸要求进行操作；     
Director实际上为施工监理，确保工人们的操作次序是符合规程的；   
Product就是具体的楼房了    

建造者模式是在当创建复杂对象的算法应该独立于对象的组成部分以及装配过程时适用的模式。        
### 14.观察者模式 ###
观察者模式定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使他们更够自动更新自己。          
观察者模式又称：发布-订阅模式         
![](https://i.imgur.com/MhQ4xoD.png)          
根据依赖倒转原则，这里的主题类和观察者基类是对具体类的抽象，使得实体类针对抽象编程，降低耦合性。     
观察者模式所做的工作其实是在解除耦合，让耦合的双方都依赖于抽象而不是具体。       

### 15.抽象工厂模式 ###
抽象工厂模式（Abstract Factory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。      
![](https://i.imgur.com/OP33485.png)           
抽象工厂与工厂方法模式相比，增加了产品的系列化，同时工厂类中提供了系列产品的生产过程。同时由于同系列产品的差异，对同系列产品增加了一层抽象，同系列的不同产品在不同工厂实例类生产。        
抽象工厂模式易于交换产品系列，由于具体工厂类，如    

		AbstractFactory factory=new ConcreteFactory1();         
在一个应用中只需要在初始化时出现一次，使得改变一个应用的具体工厂比较容易，改变具体的工厂即可使用不同系列的产品配置。      
同时，抽象工厂模式使具体创建实例的过程与客户端分离，客户端通过抽象接口操纵实例，产品的具体类名被其他具体工厂实现分离，不会出现在客户端代码中。        
**抽象工厂模式也存在缺点**      
如果要增加新的产品系列，需要添加产品系列类，同时需要对抽象工厂基类和实例类增加相应的产生生产方法。         
**通过简单工厂克服抽象工厂模式缺点**        
![](https://i.imgur.com/jXIzmQw.png)           
这里为了避免在添加新的产品系列同时需要增加抽象工厂类，使用简单工厂模式，将产品的生产和判断放入DataBase类中。       
**通过反射技术消除判断过程**            
通过反射技术来实例化一个对象：          
	
	//需要引入 System.Reflection
	Assembly.Load("程序及名称").CreateInstance("命名空间.类名称")  
例如：      
	
	//常规实例化方法
	IUser result=new SqlServerUser();
	//使用反射实例化
	IUser result=(IUser)Assembly.Load("抽象工行模式").CreateInstance("抽象工厂模式.SqlserverUser")