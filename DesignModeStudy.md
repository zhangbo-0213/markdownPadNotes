## 设计模式笔记 ##
### UML类图 ###
![](https://i.imgur.com/hGOUFKY.png)        
“动物矩形框”代表类，类图分三层：         
第一层：类名（如果为抽象类，则用希斜体表示）        
第二层：类的特性，通常为字段和属性       
第三层：类的操作，通常为方法或行为        
成员前 + 表示为public; - 表示为 private; # 表示为 protected       

“飞翔矩形框”代表借接口 ，分为两层：   
第一层：接口名称 带有 interface    
第二层：接口方法        
接口另一种标识方法：棒棒糖表示法   （讲人话接口）        

**类之间的继承关系用**：空心三角形+实线表示       
**接口的实现关系**：空心三角形+虚线表示       
**关联关系**：实线箭头表示（关联关系：一个类的实现需要知道另一个类）     
**聚合关系**：空心菱形+实线箭头（聚合关系：代表一种“弱拥有关系”，对象A可以包含B，但B对象不是A的一部分）     
**组合关系**：实心菱形+实线箭头（组合关系：代表一种”强拥有关系“，严格体现部分与整体的关系，且部分与整体具有相同的生命周期，例如 鸟与翅膀，组合关系两端的连线会有数字，表明对应端的类可以有几个实例）                  
**依赖关系**：通过虚线箭头表示（依赖关系：一个类的实现依赖于另一个类）           

### 1. 简单工厂模式 ###
简单工厂模式：通过一个单独的类来管理类的实例化过程，这个类充当“工厂”角色，负责生产产品。         
![](https://i.imgur.com/LZKmGX1.png)         
这里的OperationFactory(提供了CreateOperation静态方法)负责管理Operation的子类实例化过程，通过多态，返回父类的方式，充当工厂角色。当有新的操作产生，添加相应的Operation子类，并在OperationFactory中的CreateOperation方法中添加相应的对象生成过程。           
### 2.策略模式 ###
策略模式：定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。       
![](https://i.imgur.com/m0R8zz1.png)       
策略模式是一种定义一系列算法的方法，从概念上看，所有的算法完成相同的工作，只是实现方式不同，策略模式以相同的方式（这个相同的方式是通过Context类中提供的算法共同的行为）调用所有的算法，减少各种算法与使用算法之间的耦合程度。      
策略模式中的Strategy类层次为Context定义了一系列供重用的算法或行为，继承有助于提取出这些算法中的公共功能。     
同时，策略模式简化了单元测试，每一个算法都有自己的类，可以对自己的接口进行单独测试。                         
![](https://i.imgur.com/rvp2hit.png)       
基本的策略模式中，选择所用算法的具体实现的职责由客户端承担，并转给Context对象，而将策略模式与简单工厂模式相结合后，选择的具体实现职责可以由Context对象来承担，减轻客户端的职责。                           
将简单工厂模式与策略模式相结合，这样可以避免在使用这些行为的类中（此例中为客户端）进行条件判断语句。策略模式将这种变化的选择过程进行了封装。        
同时在此例中通过Context类管理超类的一个实例，客户端只需知道Context一个类即可，而无需像简单工厂模式需要知道超类和工厂类，Context对Strategy不同对象的生成再次进行了封装，因此，客户端只需知道Context一个类。             
### 3.单一职责原则 ###
就一个类而言，应该仅有一个引起它变化的原因。          
如果一个类承担的职责过多，就等于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。         
如果改变一个类的动机多于一个 ，则这个类就具有多于一个职责，则应该考虑职责分离。     
### 4.开放-封闭原则 ###
开放-封闭原则，是说软件实体（类，函数，模块等）应该可以扩展，但是不可修改。**对于扩展是开放的，对于修改是封闭的**。      
在最初编写代码时，假设变化不会发生，当变化发生时，创建抽象来隔离以后发生的同类变化。面对需求，对程序的改动是通过增加新代码进行，而不是更改该现有代码。        
例如，面对加法需求的时候，可以在Client只写一个加法类，而当增加更多运算的需求时，则需要通过继承和多态来隔离具体的运算过程与Client的耦合程度。           
![](https://i.imgur.com/qD7KSKl.png)              
### 5.依赖倒转原则 ###
依赖倒转原则，抽象不应该依赖细节，细节应该依赖抽象。针对接口编程，而不是针对实现编程。      
不管是高层模块还是低层模块，都应依赖于抽象，即接口或抽象类，只要接口是稳定的，任何一个更改都不用担心其他受到影响，这样高层和低层模块都可以很容易被复用。       
**里氏代换原则**      
一个软件实体使用的是一个父类的话，那么一定适用其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件中，把父类都替换成子类，程序的行为没有变化，简单来讲，子类必须要能够替换掉父类。            
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，子类也能够在父类基础上增加新的行为。        

对此，高层模块和底层模块之间不应该直接依赖，而是通过接口或抽象类          
 ![](https://i.imgur.com/BOM7TKB.png)        
### 6.装饰模式 ###
装饰模式，动态给对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。          
![](https://i.imgur.com/wgzFVED.png)              
Component定义一个对象接口，可以动态给对象添加功能。ConcreteComponent是一个实体对象，也可以为这个对象添加职责。Decorator，装饰的抽象类，继承了Component，Component（或者说ConcreteComponent）通过装饰抽象类来进行功能的扩展，对于Component类来说并不需要知道Decorator的存在。ConcreteDecorator具体的起装饰作用的对象，为Component添加功能。          
如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样，如果只有一个ConcreteDecorator类，那么就没有必要建立单独的Decorator类，而是将Decorator和ConcreteDecorator责任合并成一个类。        

装饰模式将要装饰的功能单独放在特定的类中，让这个类包装所要装饰的对象，因此，当需要执行特殊行为时，客户代码根据需要**有选择，按顺序**的使用装饰功能包装对象。         
### 7.代理模式 ###
代理模式：为其它对象提供一种代理以控制对该对象的访问。   
![](https://i.imgur.com/M8XK1OS.png)       
代理类通过实现和被代理类完全相同的接口并管理一个被代理类的实例，使在使用被代理对象的地方完全替代被代理对象。    
代理模式的应用场合：      
1. 远程代理。为一个对象在不同的地址空间提供局部代理，这样可以隐藏一个对象存在于不同地址空间的事实。  
2. 虚拟代理。根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。          
3. 安全代理。用来控制对真实对象访问得权限。      
4. 智能指引。当调用真实对象时，代理处理另外一些事。比如在计算真实对象的引用次数，当引用次数为0时，自动释放真实对象；或当第一次引用持久化对象时，将其装入内存；通过代理在访问一个对象时附加一些内务处理。         

### 8.工厂方法模式 ###
简单工厂模式的优点在于工厂类中包含必要的逻辑判断，根据客户端的选择动态实例化相关的类，对于客户端来说，去除了对产品本身的依赖。而如果此时对产品类进行扩展的话，简单工厂中的代码就要进行修改，而不是添加新的类来进行扩展，这样违背了“开放-封闭原则”，因此有工厂方法模式。   
工厂方式模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。     
工厂方法最终是创建出产品，即实例化的对象。         
![](https://i.imgur.com/DKCDLdq.png)                   
工厂方法克服了简单工厂模式所违背的“开放-封闭原则”，同时对对象的创建过程进行了封装。，工厂方法模式是对简单工厂模式的抽象和修改。但缺点在于，当增加一个产品时，需要增加新的工厂类与之对应。         

### 9.原型模式 ###
原型模式：通过原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，而不是通过实例化的方式。        
![](https://i.imgur.com/WcC79tc.png)                   
在原型模式中涉及到一个方法：        
object.MemberwiseClone()      
创建当前对象的**浅表副本**，即创建一个新的对象，将当前对象的非静态字段复制到该新对象。如果成员为值类型，则执行逐位复制，而如果是引用类型成员，则是复制引用而不是复制引用的对象。       
原型模式中的原型抽象类一般用不着，.NET在System命名空间中提供了ICloneable接口，实现该接口即可完成对应的原型。       
**浅复制**：被复制的对象所有的变量与原来对象的值相同，而所有对其他对象的引用仍然指向原来的对象，而不是引用对象的副本。       
**深复制**：深复制将引用对象的变量指向引用对象复制过的新对象，而不是指向原有的引用对象本身。       

### 10.模板方法模式 ###
模板方法模式：定义一个操作中算法的骨架部分，而将一些步骤延迟到子类当中。模板方法使得子类可以不改变一个算法的结果即可重定义该算法的某些特定步骤。          
当要完成在某一细节层次一致的一个过程或一系列步骤，但其中个别步骤更详细的层次上的细节可能不同时，通常考虑使用模板方法模式来处理。         
![](https://i.imgur.com/NnJKXSY.png)                  
AbstractClass定义实现了一个模板方法。模板方法一般是一个具体的方法，给出顶层逻辑的骨架，逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。     
模板方法通过把不变的行为提取到超类，而将变化的细节推迟到子类中去实现，形成较好的代码复用。   
### 11.迪米特法则 ###
如果两个类之间不必彼此通信，那么这两个类不应该发生直接相互作用。如果一个类需要调用另一个类的某一个方法，可以通过第三者转发调用。   
在类的设计结构上，每一个类应该尽量降低成员的访问性，不需要让其他类知道的字段或行为就不必要公开。   
迪米特法则旨在降低类与类之间的耦合性，耦合越弱，越有利于复用，处于弱耦合中的类发生修改，不会对现有关系造成强干扰。    